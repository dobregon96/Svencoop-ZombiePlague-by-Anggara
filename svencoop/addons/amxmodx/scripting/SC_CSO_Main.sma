/* Plugin generated by AMXX-Studio  */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fun>
#include <sczs_stocks>

#define PLUGIN_VERSION "1.0.4"

new const CSOMusicWav[][] = {
	"cso_anggara/Scenario_Ready.wav",
	"cso_anggara/Scenario_Rush_loop.wav",
	"cso_anggara/Scenario_Normal_loop.wav"
}

new const CSOVoxWav[][] = {
	"cso_anggara/vox/roundfail.wav",
	"cso_anggara/vox/roundclear.wav",
	"cso_anggara/vox/ten.wav",
	"cso_anggara/vox/nine.wav",
	"cso_anggara/vox/eight.wav",
	"cso_anggara/vox/seven.wav",
	"cso_anggara/vox/six.wav",
	"cso_anggara/vox/five.wav",
	"cso_anggara/vox/four.wav",
	"cso_anggara/vox/three.wav",
	"cso_anggara/vox/two.wav",
	"cso_anggara/vox/one.wav"
}

new const TauntWav[][] = {
	"fgrunt/recon.wav",
	"fgrunt/checkrecon.wav",
	"fgrunt/rapidfire.wav",
	"fgrunt/moveup.wav",
	"fgrunt/go.wav",
	"fgrunt/marines.wav",
	"fgrunt/stayalert.wav",
	"fgrunt/freaks.wav",
	"fgrunt/quiet.wav"
}

#define TASKID_FreezeTime 13300
#define TASKID_Point 13400
#define TASKID_Round 13500
#define TASKID_FAILED 13601
#define TASKID_CLEAR 13602
#define TASKID_TimeSubtract 13700
#define TASKID_SpawnZombie 13800

#define WAV_PLAY "spk ^"%s^""
#define STOP_SOUND "stopsound"

#define GetRoundTime get_pcvar_float(CvarPointer[rRoundTime])
#define ResetMaxSpeed(%1) set_user_maxspeed(%1, get_pcvar_float(CvarMaxSpeed))

#define RoundClearText "Round Clear"
#define RoundFailedText "Round Failed"

#define AllPlayerDeadText "No living players left"

#define SPHERE_RANGE 0.1

enum {
	CHAN_POINT = 3,
	CHAN_WINLOSE = 4
}

enum _:cvarEnum {
	zHealth = 0,
	zFreeroam,
	zBlood,
	zScale,
	zHealthInc,
	zInterval,
	rMaxRound,
	rRoundTime
}

new const DefaultItems[][] = {
	"weapon_pipewrench",
	"weapon_glock"
}

new Float:g_FreezeTime_duration = 0.0;
new g_Countdown_failed = 15;
new g_CurrentRoundTime;
new bool:g_IsFreezeTime = false;
new bool:g_FirstExec = true;
new MaxPlayers, CvarMaxSpeed;

new NextSpawnPoint, TotalZSpawnPoint, Trie:ZombieSpawnList;

new CvarPointer[cvarEnum];

new BiggestZSpawnIndex;

new const g_wbox_class[] = "weaponbox"
new const g_wbox_model[] = "models/w_weaponbox.mdl"
new const g_wbox_model_prefix[] = "models/w_"

public plugin_init()
{
	register_plugin("SvenCoop Zombie Scenario : Survival", PLUGIN_VERSION, "Anggara_nothing");
	
	ZombieSpawnList = TrieCreate();
	
	register_event("TextMsg", "TextMsgEvent", "a");
	
	register_forward(FM_ClientKill, "KillSwitch");
	register_forward(FM_CmdStart,"CmdStart");
	register_forward(FM_SetModel, "SetModel");
	
	register_cvar("cso_zombie_ent", ZS_DefaultMonsterClassname);
	CvarPointer[zHealth]	=	register_cvar("cso_zombie_hp", "100");
	CvarPointer[zFreeroam]	=	register_cvar("cso_zombie_freeroam", "2");
	CvarPointer[zBlood]	=	register_cvar("cso_zombie_blood", "1");
	CvarPointer[zScale]	=	register_cvar("cso_zombie_scale", "1.0");
	CvarPointer[zHealthInc]	=	register_cvar("cso_zombie_hpinc", "20");
	CvarPointer[zInterval]	=	register_cvar("cso_zombie_interval", "1.0");
	
	CvarPointer[rMaxRound]	=	register_cvar("cso_round_max", "20");
	CvarPointer[rRoundTime]	=	register_cvar("cso_round_time", "180");
	
	CvarMaxSpeed = get_cvar_pointer("sv_maxspeed");
	
	MaxPlayers = get_maxplayers();
	NextSpawnPoint = MaxPlayers+1;
}

public plugin_precache()
{
	static i;
	for(i = 0; i < sizeof(CSOMusicWav); i++)
		precache_sound(CSOMusicWav[i]);
		
	for(i = 0; i < sizeof(CSOVoxWav); i++)
		precache_sound(CSOVoxWav[i])
	
	for(i = 0; i < sizeof(TauntWav); i++)
		precache_sound(TauntWav[i])
}

public plugin_cfg()
{
	new configs[32]
	get_configsdir(configs, charsmax(configs))
	
	server_cmd("exec %s/SC_scenario.cfg", configs)
}

public plugin_end()
{
	// destroy trie
	TrieDestroy(ZombieSpawnList);
}

public client_putinserver(id)
{
	CheckActivation();
	
	set_task(3.0, "UpdatePlayerPointInfo", TASKID_Point+id)
	set_task(3.0, "UpdateRoundInfo",        TASKID_Round+id)
}

// "kill" command blocked
public KillSwitch(id) return FMRES_SUPERCEDE;

// Block attack on freeze time
public CmdStart(id, uc_handle, seed)
{
    if(!is_user_alive(id) || zs_get_survival_status() == ZS_STATUS_INACTIVE) return FMRES_IGNORED;
        
    if(zs_get_survival_status() == ZS_STATUS_FREEZE)
    {
	static buttons;
	buttons = get_uc(uc_handle, UC_Buttons);
	
    	if(g_IsFreezeTime)
	{
		set_user_maxspeed(id, 1.0);
		
		buttons &= ~IN_ATTACK;		// block primary attack
		buttons &= ~IN_ATTACK2;		// block secondary attack
		buttons &= ~IN_ALT1;		// block tertiary attack
		set_uc(uc_handle, UC_Buttons, buttons);
		
	}
	else
	{
		// in case any ugly bugs show up
		ResetMaxSpeed(id); 	
	}
    }
    /*else
    {
    	static aim_origin_int[3], Float:aim_origin_fl[3];
	get_user_origin(id, aim_origin_int, 3);
	
	for(new i = 0; i < sizeof(aim_origin_fl); i++)
	{
		aim_origin_fl[i] = float(aim_origin_int[i]);
	}
	
	new ent_hitted = -1;
	while( (ent_hitted = find_ent_in_sphere(ent_hitted, aim_origin_fl, SPHERE_RANGE)) )
	{
		if( !pev_valid(ent_hitted) )
			continue;
		
		static classname[16];
		pev(ent_hitted, pev_classname, classname, charsmax(classname));
		if( equal(classname, "func_breakable") )
		{
			static Float:wallhp, spflags;
			pev(ent_hitted, pev_health, wallhp);
			spflags = pev(ent_hitted, pev_spawnflags);
			
			if( (spflags & SF_BREAK_TRIGGER_ONLY) )
				continue;
			
			static textcenter[46];
			formatex(textcenter, charsmax(textcenter), "Wall : %.f", wallhp);
			if( spflags & SF_BREAK_REPAIRABLE )
			{
				strcat(textcenter, " (Repairable)", charsmax(textcenter));
			}
			
			client_print(id, print_center, textcenter);
			break;
		}
	}
    }*/
    
    return FMRES_IGNORED;
}

// Set owner for dropped weapon
public SetModel(ent, const mdl[])
{
	if (!pev_valid(ent) || !equali(mdl, g_wbox_model_prefix, sizeof g_wbox_model_prefix - 1) || equali(mdl, g_wbox_model))
	return FMRES_IGNORED

	new id = pev(ent, pev_owner)
	if (!(1 <= id <= MaxPlayers))
		return FMRES_IGNORED
		
	static class[32]
	pev(ent, pev_classname, class, sizeof class - 1)
	if (!equal(class, g_wbox_class))
		return FMRES_IGNORED

	if (!is_user_alive(id))
		set_pev(ent, pev_iuser3, id);
	else
		return FMRES_IGNORED

	return FMRES_IGNORED
}

public TextMsgEvent()
{
	new destination = read_data(1);
	static text[32];
	read_data(2, text, charsmax(text));
	
	if(destination == print_center && equal(text, AllPlayerDeadText) && !task_exists(TASKID_FAILED))
	{
		g_Countdown_failed = 15;
		set_task(1.0, "Round_Failed", TASKID_FAILED, _,_, "b");
	}
	
	return PLUGIN_CONTINUE;
}

public CheckActivation()
{
	if(zs_is_survival_mode_enabled() == -1)
	{
		pause("d");
		return;
	}
	
	if(zs_is_survival_mode_enabled() == 1 && g_FirstExec)
	{
		g_FirstExec = false;
		ChangeGeneralCvars();
		LoadZombieSpawnPoints();
		new ent = engfunc(EngFunc_FindEntityByString,0,"classname","func_buyzone")
		if(ent)
		{
			pev(ent, ZS_DELAY_TIME, g_FreezeTime_duration);
			if(g_FreezeTime_duration > 0.0 &&
			    zs_get_survival_status() == ZS_STATUS_FREEZE)
			{
				zs_set_round_number(1);
				StartFreezeTime(g_FreezeTime_duration, true);
			}
		}
	}
}

public UpdatePlayerPointInfo(task_id)
{
	new id = task_id - TASKID_Point;
	if(!is_user_connected(id) || zs_is_survival_mode_enabled() == -1){ remove_task(task_id); return; }
	
	if(is_user_alive(id)) {
		// posisi di cs 0.85, 0.90
		set_hudmessage(255, 0, 0, 0.02, 0.17, 0, 0.0, 1.2, 0.0, 0.0, CHAN_POINT)
		show_hudmessage(id, "Zombies : %d^nPoint(s) : %d", zs_get_zombie_counts(), get_user_frags(id))
	}
	
	set_task(1.0, "UpdatePlayerPointInfo", task_id)
	
}

public UpdateRoundInfo(task_id)
{
	new id = task_id - TASKID_Round;
	if(is_user_connected(id) && zs_is_survival_mode_enabled() != -1) {
		static roundtime[10];
		// posisi di cs 0.85, 0.90
		UTIL_RoundTimeFormat(roundtime, 9, g_CurrentRoundTime);
		set_hudmessage(42, 127, 255, -1.0, 0.06, 0, 0.0, 1.1, 0.0, 0.0, CHAN_WINLOSE);
		show_hudmessage(id, "[Round] [%d]^n[Max Round] [%d]^n[Time] [%s]", zs_get_round_number(), get_pcvar_num(CvarPointer[rMaxRound]), roundtime);
	}
	else { remove_task(task_id); return; }
	
	set_task(0.9, "UpdateRoundInfo", task_id)
}

public FreezeTime(taskid)
{
	g_FreezeTime_duration -= 1.0;
	if(g_FreezeTime_duration <= 0.0)
	{
		g_IsFreezeTime = false;
		remove_task(taskid);
		Round_Started();
		return;
	}
	else
	{
		g_IsFreezeTime = true;
		for(new id = 1; id < MaxPlayers; id++)
		{
			if(is_user_connected(id))
			{
				new WaitText[256];
				formatex(WaitText, 255, "The game will begin in %d second(s).", floatround(g_FreezeTime_duration))
				if(g_FreezeTime_duration == 20.0)
				{
					client_cmd(id, WAV_PLAY, CSOMusicWav[0]); 
				}
				else if(g_FreezeTime_duration > 20.0)
				{
					static text[9];
					UTIL_RoundTimeFormat(text, 8, floatround(g_FreezeTime_duration));
					formatex(WaitText, 255, "Waiting for other players. (%s)", text)
				}
				
				client_print(id, print_center, WaitText);
			}
		}
	}
}

public Round_Started()
{
	SetRoundTime(GetRoundTime);
	zs_set_survival_status(ZS_STATUS_RUNNING);
	set_task(get_pcvar_float(CvarPointer[zInterval]), "ZombieSpawner", TASKID_SpawnZombie, .flags = "b");
	
	for(new id = 1; id < MaxPlayers; id++)
	{
		if(is_user_connected(id))
		{
			PlayRoundMusic(id);
			PlayPlayerTaunt(id);
			ResetMaxSpeed(id);
		}
	}

	remove_task(TASKID_CLEAR);
	set_task(GetRoundTime, "Round_Clear", TASKID_CLEAR);
}

public Round_Clear()
{
	new trash[32], num_alive;
	get_players(trash, num_alive, "ah");
	
	if(num_alive > 0)
	{
		remove_task(TASKID_SpawnZombie);
		zs_terminate_zombies();
		for(new id = 1; id < MaxPlayers; id++)
		{
			if(is_user_connected(id))
			{
				if(task_exists(TASKID_Round+id)) remove_task(TASKID_Round+id);
				set_hudmessage(42, 127, 255, -1.0, 0.2, 0, 0.1, 5.0, .channel = CHAN_WINLOSE);
				show_hudmessage(id, RoundClearText);
				

				client_cmd(id, STOP_SOUND);
				client_cmd(id, WAV_PLAY, CSOVoxWav[1]);
			}
		}
		
		if(zs_get_round_number() >= get_pcvar_num(CvarPointer[rMaxRound]))
		{
			set_task(10.0, "ChangelevelNextMap");
		}
		else
		{
			set_task(5.1, "StartNewRound");
			set_task(4.5, "AddRoundNumber");
		}
	}
}

public Round_Failed(task_id)
{
	if(g_Countdown_failed < 1)
	{
		remove_task(task_id);
		StartNewRound();
		return;
	}
	else {
		remove_task(TASKID_CLEAR);
		for(new id = 1; id < MaxPlayers; id++) {
			if(is_user_connected(id)) {
				if(task_exists(TASKID_Round+id)) remove_task(TASKID_Round+id);
				if(g_Countdown_failed == 15) {
					remove_task(TASKID_SpawnZombie);

					client_cmd(id, STOP_SOUND);
					client_cmd(id, WAV_PLAY, CSOVoxWav[0]);
					set_hudmessage(200, 0, 0, -1.0, 0.2, 0, 0.0, 2.0, 0.0, 0.0, CHAN_WINLOSE);
					show_hudmessage(id, RoundFailedText);
				}
				else if(g_Countdown_failed < 11) {
					client_cmd(id, WAV_PLAY, CSOVoxWav[12-g_Countdown_failed]);
					set_hudmessage(42, 127, 255, -1.0, 0.2, 0, 0.1, 2.0,.channel = CHAN_WINLOSE);
					show_hudmessage(id, "Continue?^n%d", g_Countdown_failed);
				}
				else {
					set_hudmessage(200, 0, 0, -1.0, 0.2, 0, 0.0, 2.0, 0.0, 0.0, CHAN_WINLOSE);
					show_hudmessage(id, RoundFailedText);
				}
			}
		}
	}
	g_Countdown_failed--;
}

public StartNewRound()
{
	remove_task(TASKID_SpawnZombie);
	remove_task(TASKID_CLEAR);
	zs_terminate_zombies(ZS_TERMINATE_REMOVE);
	zs_spawn_all_players();
	// Delay it because too soon
	set_task(2.0, "ResupplyPlayers");
	zs_set_survival_status(ZS_STATUS_FREEZE);
	
	SetRoundTime(GetRoundTime + 21.0);
	StartFreezeTime(21.0, false)
	
	for(new id = 1; id < MaxPlayers; id++) if(is_user_connected(id)) {
		set_task(1.0, "UpdateRoundInfo",        TASKID_Round+id, _, _, "b");
	}
}

public ChangelevelNextMap()
{
	new ent = -1, mapname[32];
	while( (ent = find_ent_by_class(ent, "func_buyzone")) )
	{
		entity_get_string(ent, EV_SZ_viewmodel, mapname, 31);
		server_cmd("changelevel %s", mapname);
		return 1;
	}
	
	return 0;
}

public StartFreezeTime(Float:new_freezetime, bool:change_roundtime)
{
	if(!task_exists(TASKID_FreezeTime))
	{
		g_FreezeTime_duration = new_freezetime;
		g_IsFreezeTime = true;
		set_task(1.0, "FreezeTime", TASKID_FreezeTime, _, _, "b")
		
		if(change_roundtime) SetRoundTime(g_FreezeTime_duration);
	}
}

public SetRoundTime(Float:newtime)
{
	g_CurrentRoundTime = floatround(newtime, floatround_floor);
	remove_task(TASKID_TimeSubtract);
	set_task(1.0, "RoundTimeSubtraction", TASKID_TimeSubtract,_,_,"b");
}

public RoundTimeSubtraction(taskid)
{
	if(g_CurrentRoundTime > 0) g_CurrentRoundTime--;
	else remove_task(taskid)
}

public AddRoundNumber()
{
	new CurrentRound = zs_get_round_number();
	zs_set_round_number(++CurrentRound);
}

public PlayPlayerTaunt(id)
{	
	new rnd_taunt = random_num(0, sizeof(TauntWav)-1);
	if(is_user_connected(id))
	{
		client_cmd(id, WAV_PLAY, TauntWav[rnd_taunt]); 
	}
}

public PlayRoundMusic(id)
{
	if(is_user_connected(id))
	{
		if(zs_get_round_number() % 2 != 0) client_cmd(id, WAV_PLAY, CSOMusicWav[1]); 
		else 			client_cmd(id, WAV_PLAY, CSOMusicWav[2]); 
	}
}

public ResupplyPlayers()
{
	new id;
	for(id = 1; id < MaxPlayers; id++)
	{
		if(is_user_alive(id))
		{
			if(get_user_health(id) < 100) set_user_health(id, 100);
			
			// Give them default items
			for(new i = 0; i < sizeof(DefaultItems); i++)
				give_item(id, DefaultItems[i]);
		}
	}
	
	// Return dropped weapons when death to owner
	new ent = -1;
	while( (ent = find_ent_by_class(ent, "weaponbox")) )
	{
		id = pev(ent, pev_iuser3);
		
		if((1 <= id <= MaxPlayers) && is_user_alive(id))
		{
			new Float:origin[3]; pev(id, pev_origin, origin);
			set_pev(ent, pev_origin, origin);
			drop_to_floor(ent);
		}
	}
}

public ZombieSpawner(task_id)
{
	if(NextSpawnPoint > BiggestZSpawnIndex) NextSpawnPoint = MaxPlayers + 1;
	
	if(zs_get_zombie_counts() < 22)
	{
		for(new ent = NextSpawnPoint; ent <= BiggestZSpawnIndex; ent++)
		{
			new buffer[7], EntId; num_to_str(ent, buffer, 6);
			if(TrieGetCell(ZombieSpawnList, buffer, EntId))
			{
				CreateZombie(EntId);
				NextSpawnPoint = ent + 1;
				break; // stop any exec after this :/
			}
			else NextSpawnPoint = ent + 1;
		}
	}
}

public CreateZombie(spawnent)
{
	// make it sure not overloaded
	if(zs_get_zombie_counts() < 22)
	{
		new Float:origin[3], angle[3], health_formula; static value[32];
		pev(spawnent, pev_origin, origin);
		pev(spawnent, pev_angles, angle);
		
		zs_get_zombie_classname(value, charsmax(value));
		
		new ent = create_entity(value);
		set_pev(ent, pev_origin, origin);
		set_pev(ent, pev_angles, angle);
		
		DispatchKeyValue(ent, "spawnflags", "2");
		
		health_formula = get_pcvar_num(CvarPointer[zHealth]) + (get_pcvar_num(CvarPointer[zHealthInc]) * (zs_get_round_number()-1))
		formatex(value, charsmax(value), "%d", health_formula);
		DispatchKeyValue(ent, "health", value);
		
		formatex(value, charsmax(value), "%d", get_pcvar_num(CvarPointer[zFreeroam]));
		DispatchKeyValue(ent, "freeroam", value);
		
		formatex(value, charsmax(value), "%d", get_pcvar_num(CvarPointer[zBlood]));
		DispatchKeyValue(ent, "bloodcolor", value);
		
		formatex(value, charsmax(value), "%f", get_pcvar_float(CvarPointer[zScale]));
		DispatchKeyValue(ent, "scale", value);
		
		DispatchKeyValue(ent, "weapons", "32");
		DispatchSpawn(ent);
	}
}

public ChangeGeneralCvars()
{
	if(zs_get_survival_status() != ZS_STATUS_INACTIVE)
	{
		// Advanced AI
		set_cvar_num("sv_ai_enemy_detection_mode", 1);
		
		// Disable weapon auto spawn & weapon drop
		set_cvar_num("mp_weaponstay",		0);
		set_cvar_num("mp_weapon_respawndelay",	-1);
		set_cvar_num("mp_ammo_respawndelay",	-1);
		set_cvar_num("mp_item_respawndelay",	-1);
		set_cvar_num("npc_dropweapons",		0);
		
		// Displacer's tertiary attack
		set_cvar_num("weaponmode_displacer",	1);
		
		// Disable damage balancing
		set_cvar_num("mp_disable_pcbalancing",	1);
		
		// AutoRespawn
		set_cvar_num("mp_forcerespawn",		1);
		set_cvar_num("mp_respawndelay",		0);
	}
}

public LoadZombieSpawnPoints()
{
	// Reset trie when executed again
	if(TotalZSpawnPoint) 
	{ 
		TotalZSpawnPoint = 0;
		BiggestZSpawnIndex = 0;
		TrieClear(ZombieSpawnList);
	}
	
	new ent = -1;
	while( (ent = find_ent_by_class(ent, "zombiespawn")) )
	{
		// 1000000 (7 cells)
		new IdKeyValue = pev(ent, pev_iuser1);
		static temp[7]; format(temp, charsmax(temp), "%d", IdKeyValue);
		// Not added yet?
		if(!TrieKeyExists( ZombieSpawnList, temp))
		{
			// Add it to trie
			TrieSetCell(ZombieSpawnList, temp, ent);
			
			if(IdKeyValue > BiggestZSpawnIndex)
				BiggestZSpawnIndex = IdKeyValue;
			
			TotalZSpawnPoint++; // increase the count
		}
	}
}

